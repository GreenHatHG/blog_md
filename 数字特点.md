---
title: 数字特点
date: 2018-04-26 09:06:22
tags:
---

能被整除的那些事

<!-- more -->

# 能被2整除

若一个整数的末位是0、2、4、6或8，则这个数能被2整除。 

# 能被3整除

若一个整数的数字和能被3整除，则这个整数能被3整除。 

# 能被4整除

若一个整数的末尾两位数能被4整除，则这个数能被4整除

# 能被5整除

若一个整数的末位是0或5，则这个数能被5整除

# 能被6整除

能被6整除的数的特征末尾是0、2、4、6、8且各位上数字的和能被3整除  
能被6整除的数的特征既要符合能被2整除的数的特征,又要符合能被3整除的数的特征  

# 能被7整除

若一个整数的个位数字截去，再从余下的数中，减去个位数的2倍，如果差是7的倍数，则原数能被7整除。如果差太大或心算不易看出是否7的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止。例如，判断133是否7的倍数的过程如下：13－3×2＝7，所以133是7的倍数；又例如判断6139是否7的倍数的过程如下：613－9×2＝595 ， 59－5×2＝49，所以6139是7的倍数，余类推。 

# 能被8整除

若一个整数的未尾三位数能被8整除，则这个数能被8整除

# 能被9整除

若一个整数的数字和能被9整除，则这个整数能被9整除

# 能被10整除

若一个整数的末位是0，则这个数能被10整除。

# 能被11整除

若一个整数的奇位数字之和与偶位数字之和的差能被11整除，则这个数能被11整除。11的倍数检验法也可用上述检查7的「割尾法」处理！过程，唯一不同的是：倍数不是2而是1！

# 能被12整除

若一个整数能被3和4整除，则这个数能被12整除

# 能被13整除

若一个整数的个位数字截去，再从余下的数中，加上个位数的4倍，如果差是13的倍数，则原数能被13整除。如果差太大或心算不易看出是否13的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止。 

# 能被17整除

- 若一个整数的个位数字截去，再从余下的数中，减去个位数的5倍，如果差是17的倍数，则原数能被17整除。如果差太大或心算不易看出是否17的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止
- 若一个整数的末三位与3倍的前面的隔出数的差能被17整除，则这个数能被17整除

# 能被19整除

- 若一个整数的个位数字截去，再从余下的数中，加上个位数的2倍，如果差是19的倍数，则原数能被19整除。如果差太大或心算不易看出是否19的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止
- 若一个整数的末三位与7倍的前面的隔出数的差能被19整除，则这个数能被19整除

# 能被23整除

若一个整数的末四位与前面5倍的隔出数的差能被23(或29)整除，则这个数能被23整除

# 能被43整除

- 若一个整数去掉末两位数字后扩大14倍与末两位数字的数的和（得到和后可重复进行），若最后结果能被43整除，则该数就能被43整除，否则不能(如果在重复计算的过程中有重复数出现，则可以判断这个数不能被43整除)。
- 一个整数的个位数字扩大13倍与去掉个位数字后的数的和（得到和后可重复进行），若最后结果能被43整除，则该数就能被43整除，否则就不能(如果在重复计算的过程中有重复数出现，则可以判断这个数不能被43整除)。

# 能被7,11,13整除

若一个整数数的末三位数与末三位数以前的数字所组成的数之差能被7、11、13整除，则这个数能被7、11、13整除。

# 整除的性质

```
(1)若a|b，且b|c，则a|c。
(2)若a|b且a|c，等价于对于任意的整数x、y，有a|(b*x+c*y)。
(3)设m≠0，则a|b等价于(m*a)|(m*b)。
(4)若a|b，且b|a，则a=±b。
(5)若a|b且b≠0，则|a|≤|b|。
(6)设整数x、y满足下式：a*x+b*y=1，且a|n，b|n，那么(a*b)|n。
```

参考:[关于整除](http://acm.sdibt.edu.cn/blog/?p=1204)

# 大数被整除的万能公式

除了用大数整除方法外，可以试试下面的万能公式  

原理：每一个A都可以分解成n*B+C，其中C为A%B的值，这样的话我们能够想到一个数可以将其前缀每次都modB，最后得到的数如果是0的话，那么能够整除，否者不能整除

```c++
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string str;
    cin >> str; //输入被除数
    int n;
    cin >> n;   //输入除数
    int temp = 0;
    for(int i = 0; i < str.size();i++)
    {
        temp *= 10;
        temp += str[i];
        temp %= n;
        //temp = (temp * 10 + (str[i] - '0')) % n;		//整合式子
    }
    if(temp % n == 0)
        cout << "1" << endl; //能被整除
    else
        cout << "0" << endl;
    return 0;
}
```

解读：  

要判断的这个数先拆分成两个数的和或者差，要求较大数必须是这个数的倍数，这样我们只要判断较小的数就可以了。如果较小的这个数也能被这个数整除，我们就说原来这个数也一定能被这个数整除。

- 936能不能被7整除。  

我们要判断936这个数能不能被7整除，可以先把936拆成两个数的和：936=910+26。由于较大数910是7的倍数(能被7整除)，因此我们只要判断较小数26能不能被7整除就行了。因为26不是7的倍数，不能被7整除，所以936也一定不能被7整除。   

所以我们通过拆分法来解释这个问题

- 我们随便取一个数289  

2/17=0.......2相当于289-17*0=289  

28/17=1.......11相当于289-17*10=119  

119不能被17整除  

- 34    

3%17=0.......3相当于34-17*0=34  

34%17=2......0相当于34-17*2=0！  

