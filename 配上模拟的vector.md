---
title: 配上模拟的vector
date: 2019-02-17 19:57:30
categories: 水题
tags:
- 模拟
- vector
mathjax: true
---

天梯赛练习L1-049 天梯赛座位分配

<!-- more -->

# [L1-049 天梯赛座位分配](https://pintia.cn/problem-sets/994805046380707840/problems/type/7)

## 题目

**题目描述**

天梯赛每年有大量参赛队员，要保证同一所学校的所有队员都不能相邻，分配座位就成为一件比较麻烦的事情。为此我们制定如下策略：假设某赛场有 N 所学校参赛，第 i 所学校有 M[i] 支队伍，每队 10 位参赛选手。令每校选手排成一列纵队，第 i+1 队的选手排在第 i 队选手之后。从第 1 所学校开始，各校的第 1 位队员顺次入座，然后是各校的第 2 位队员…… 以此类推。如果最后只剩下 1 所学校的队伍还没有分配座位，则需要安排他们的队员隔位就坐。本题就要求你编写程序，自动为各校生成队员的座位号，从 1 开始编号。

**输入格式**

输入在一行中给出参赛的高校数 N （不超过100的正整数）；第二行给出 N 个不超过10的正整数，其中第 i 个数对应第 i 所高校的参赛队伍数，数字间以空格分隔。

**输出格式**

从第 1 所高校的第 1 支队伍开始，顺次输出队员的座位号。每队占一行，座位号间以 1 个空格分隔，行首尾不得有多余空格。另外，每所高校的第一行按“#X”输出该校的编号X，从 1 开始。

**样例1**

输入

```
3
3 4 2
```

输出

```
#1
1 4 7 10 13 16 19 22 25 28
31 34 37 40 43 46 49 52 55 58
61 63 65 67 69 71 73 75 77 79
#2
2 5 8 11 14 17 20 23 26 29
32 35 38 41 44 47 50 53 56 59
62 64 66 68 70 72 74 76 78 80
82 84 86 88 90 92 94 96 98 100
#3
3 6 9 12 15 18 21 24 27 30
33 36 39 42 45 48 51 54 57 60
```

# 解析

让每个学校的学生排成一排，为每一个座位安排学生。
每把椅子依次从每个学校面前走过，如果这个学校还有学生没被安排座位，那就安排，安排方案为：
如果此座位前一个不是本校学生，那么抓一个此校学生做在这把椅子上，并标记这把椅子被此校学生坐了，
如果此座位前一个是本校学生，那此位置空着，抓一个此校学生做在这把椅子的后一把上，并标记这把椅子的后一把被此校学生坐了。

参考：[https://www.liuchuo.net/archives/5082](https://www.liuchuo.net/archives/5082)

```c++
/*
2019/2/17 17:20:00		8 ms
*/
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1E4;
int sc[MAXN] = {0}; //一个学校的队伍里面的人数
vector<int>vec[MAXN]; //第i个座位上做的是哪个学校的学生。
int vis[MAXN] = {0}; //这个座位有没有坐过了

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> sc[i];
        sc[i] *= 10;
    }
    int index = 1, num = 0; //index:学校的序号，num:当前已经排完的学校的数量
    while(num < n) 
    {
        for(int i = 1; i <= n; i++)
        {
            if(vec[i].size() < sc[i]) //这个学校的队伍还没有排完
            {
                vec[i].push_back(index); //放到专属的vector里面
                if(num == n-1) //只有一个队伍
                    index += 2; //得隔空排
                else
                    index++;
            }
            if(vec[i].size() == sc[i] && vis[i] == 0) //已经排完
            {
                vis[i] = 1;
                num++; 
            }
        }
    }
    for(int i = 1; i <= n; i++)
    {
        cout << "#" << i << endl;
        for(int j = 0; j < vec[i].size(); j++)
        {
            if(j != 0 && (j+1) % 10 == 0)
                cout << vec[i][j] << endl;
            else
                cout << vec[i][j] << " ";
        }
    }
    return 0;
}

```

