---
title: 数论
date: 2018-05-24 15:09:22
categories: 算法
tags: 数论
---

欧几里得及其扩展，素数，模运算。

<!-- more -->

# 欧几里得--最大公约数

## gcd（a, b) = gcd(b, a mod b)

```c++
int gcd(int a, int b)
{
    if(b == 0)
        return a;
    return gcd(b, a % )b;
}
```

一波应用：[线段上格点个数---挑战编程---欧几里得](https://www.cnblogs.com/kimsimple/p/6680820.html)

## \<algorithm>库的std::_gcd函数

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int a = 8;
    int b = 12;
    cout <<__gcd(a, b); //两个'_'
    return 0;
}
//out：4   //g++-4.8 
```

## 最小公倍数(LCM)和最大公约数(GCD)

`lcm(a, b) = (a*b)/gcd(a,b)`

## 扩展欧几里得

基本算法：对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。

```c++
int exgcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    int r=exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
    return r;
}
```

# 素数

**埃氏筛法**---求解n以内的素数个数

```c++
int prime[MAXN]; //第i个素数的值
bool is_prime[MAXN]; //is_prime[i]为true时表示i是素数

//返回n以内素数的个数
int solve(int n)
{
    int p = 0; //代表素数个数
    for(int i = 2; i <= n; i++)
        is_prime[i] = true;
    for(int i = 2; i <= n; i++)
    {
        if(is_prime[i])
        {
            prime[p++] = i; //每有一个素数，p就++，然后prime存的就是素数的值，然后进行筛选
            for(int j = 2 * i; j <= n; j += i)
                is_prime[j] = false;
        }
    }
    return p; //prime[p - 1]代表n以内最大的素数
}
```

# 模运算

**一些基本规则**

[https://blog.csdn.net/x_i_y_u_e/article/details/50823235](https://blog.csdn.net/x_i_y_u_e/article/details/50823235)

**除法取模与费马小定理**

[http://www.cnblogs.com/ECJTUACM-873284962/p/6847672.html](http://www.cnblogs.com/ECJTUACM-873284962/p/6847672.html)

[https://blog.csdn.net/liangzhaoyang1/article/details/56514028](https://blog.csdn.net/liangzhaoyang1/article/details/56514028)

# 快速幂

```c++
typedef long long ll;
ll mod_pow(ll x, ll n, ll mod) //x^n % mod
{
    ll ans = 1;
    while(n > 0) //遍历所有二进制位
    {
        if(n & 1) //对应n的二进制位是不是1
            ans = ans * x % mod; //乘上x^(2^i)
        x = x * x % mod;  //x平方
        n >>== 1;
    }
    return ans;
}
```

